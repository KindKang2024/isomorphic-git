import \'dart:async\';\nimport \'dart:convert\';\nimport \'dart:typed_data\';\n\nimport \'../commands/current_branch.dart\';\nimport \'../errors/missing_parameter_error.dart\';\nimport \'../errors/remote_capability_error.dart\';\nimport \'../managers/git_config_manager.dart\';\nimport \'../managers/git_ref_manager.dart\';\nimport \'../managers/git_remote_manager.dart\';\nimport \'../managers/git_shallow_manager.dart\';\nimport \'../models/file_system.dart\';\nimport \'../models/git_commit.dart\';\nimport \'../models/git_pack_index.dart\';\nimport \'../models/http_client.dart\';\nimport \'../storage/has_object.dart\';\nimport \'../storage/read_object.dart\';\nimport \'../utils/abbreviate_ref.dart\';\nimport \'../utils/collect.dart\';\nimport \'../utils/empty_packfile.dart\';\nimport \'../utils/filter_capabilities.dart\';\nimport \'../utils/for_await.dart\';\nimport \'../utils/join.dart\';\nimport \'../utils/pkg.dart\';\nimport \'../utils/split_lines.dart\';\nimport \'../wire/parse_upload_pack_response.dart\';\nimport \'../wire/write_upload_pack_request.dart\';\nimport \'../utils/callbacks.dart\';\n\nclass FetchResult {\n  String? defaultBranch;\n  String? fetchHead;\n  String? fetchHeadDescription;\n  Map<String, String>? headers;\n  List<String>? pruned;\n  String? packfile; // Added for Dart\n\n  FetchResult({\n    this.defaultBranch,\n    this.fetchHead,\n    this.fetchHeadDescription,\n    this.headers,\n    this.pruned,\n    this.packfile, // Added for Dart\n  });\n}\n\nclass FetchHeadInfo {\n  String oid;\n  String description;\n  FetchHeadInfo({required this.oid, required this.description});\n}\n\nFuture<FetchResult> fetch({\n  required FileSystem fs,\n  required dynamic cache,\n  required HttpClient http,\n  ProgressCallback? onProgress,\n  MessageCallback? onMessage,\n  AuthCallback? onAuth,\n  AuthFailureCallback? onAuthFailure,\n  AuthSuccessCallback? onAuthSuccess,\n  required String gitdir,\n  String? url,\n  String? corsProxy,\n  String? ref,\n  String? remoteRef,\n  String? remote,\n  bool singleBranch = false,\n  bool tags = false,\n  int? depth,\n  DateTime? since,\n  List<String> exclude = const [],\n  bool relative = false,\n  Map<String, String> headers = const {},\n  bool prune = false,\n  bool pruneTags = false,\n}) async {\n  final currentBranchName = await currentBranch(fs: fs, gitdir: gitdir, test: true);\n  final config = await GitConfigManager.get(fs: fs, gitdir: gitdir);\n\n  remote = remote ?? (currentBranchName != null ? await config.get(\'branch.$currentBranchName.remote\') : null) ?? \'origin\';\n  url = url ?? await config.get(\'remote.$remote.url\');\n\n  if (url == null) {\n    throw MissingParameterError(\'remote OR url\');\n  }\n\n  remoteRef = remoteRef ?? (currentBranchName != null ? await config.get(\'branch.$currentBranchName.merge\') : null) ?? ref ?? \'HEAD\';\n  corsProxy = corsProxy ?? await config.get(\'http.corsProxy\');\n\n  final remoteHelper = GitRemoteManager.getRemoteHelperFor(url: url);\n  final discovered = await remoteHelper.discover(\n    http: http,\n    onAuth: onAuth,\n    onAuthSuccess: onAuthSuccess,\n    onAuthFailure: onAuthFailure,\n    corsProxy: corsProxy,\n    service: \'git-upload-pack\',\n    url: url,\n    headers: headers,\n    protocolVersion: 1,\n  );\n\n  final discoveredAuth = discovered.auth;\n  final remoteRefsMap = discovered.refs;\n\n  if (remoteRefsMap.isEmpty) {\n    return FetchResult(\n      defaultBranch: null,\n      fetchHead: null,\n      fetchHeadDescription: null,\n    );\n  }\n\n  if (depth != null && !discovered.capabilities.contains(\'shallow\')) {\n    throw RemoteCapabilityError(\'shallow\', \'depth\');\n  }\n  if (since != null && !discovered.capabilities.contains(\'deepen-since\')) {\n    throw RemoteCapabilityError(\'deepen-since\', \'since\');\n  }\n  if (exclude.isNotEmpty && !discovered.capabilities.contains(\'deepen-not\')) {\n    throw RemoteCapabilityError(\'deepen-not\', \'exclude\');\n  }\n  if (relative == true && !discovered.capabilities.contains(\'deepen-relative\')) {\n    throw RemoteCapabilityError(\'deepen-relative\', \'relative\');\n  }\n\n  final resolvedRef = GitRefManager.resolveAgainstMap(ref: remoteRef, map: remoteRefsMap);\n  final oid = resolvedRef.oid;\n  final fullref = resolvedRef.fullref;\n\n  final filteredRemoteRefs = Map<String, String>.from(remoteRefsMap);\n  for (final key in remoteRefsMap.keys) {\n    if (key == fullref ||\n        key == \'HEAD\' ||\n        key.startsWith(\'refs/heads/\') ||\n        (tags && key.startsWith(\'refs/tags/\'))) {\n      continue;\n    }\n    filteredRemoteRefs.remove(key);\n  }\n\n  var capabilities = filterCapabilities(\n    discovered.capabilities.toList(),\n    [\n      \'multi_ack_detailed\',\n      \'no-done\',\n      \'side-band-64k\',\n      \'ofs-delta\',\n      \'agent=${pkg.agent}\',\n    ],\n  );\n  if (relative) capabilities.add(\'deepen-relative\');\n\n  final wants = singleBranch ? [oid] : filteredRemoteRefs.values.toList();\n\n  final haveRefsList = singleBranch\n      ? (ref != null ? [ref] : [])\n      : await GitRefManager.listRefs(fs: fs, gitdir: gitdir, filepath: \'refs\');\n\n  var haves = <String>[];\n  for (var hRef in haveRefsList) {\n    try {\n      hRef = await GitRefManager.expand(fs: fs, gitdir: gitdir, ref: hRef);\n      final hOid = await GitRefManager.resolve(fs: fs, gitdir: gitdir, ref: hRef);\n      if (await hasObject(fs: fs, cache: cache, gitdir: gitdir, oid: hOid)) {\n        haves.add(hOid);\n      }\n    } catch (_) {}\n  }\n  haves = haves.toSet().toList(); // Unique values\n\n  final shallowOids = await GitShallowManager.read(fs: fs, gitdir: gitdir);\n  final shallows = discovered.capabilities.contains(\'shallow\') ? shallowOids.toList() : <String>[];\n\n  final packStream = writeUploadPackRequest(\n    capabilities: capabilities,\n    wants: wants,\n    haves: haves,\n    shallows: shallows,\n    depth: depth,\n    since: since,\n    exclude: exclude,\n  );\n\n  final packBuffer = Uint8List.fromList(await collect(packStream));\n\n  final rawResponse = await remoteHelper.connect(\n    http: http,\n    onProgress: onProgress,\n    corsProxy: corsProxy,\n    service: \'git-upload-pack\',\n    url: url,\n    auth: discoveredAuth,\n    body: [packBuffer],\n    headers: headers,\n  );\n\n  final uploadPackResponse = await parseUploadPackResponse(rawResponse.body);\n  if (rawResponse.headers != null) {\n    uploadPackResponse.headers = rawResponse.headers;\n  }\n\n  for (final shallowOid in uploadPackResponse.shallows) {\n    if (!shallowOids.contains(shallowOid)) {\n      try {\n        final objectResult = await readObject(fs: fs, cache: cache, gitdir: gitdir, oid: shallowOid);\n        final commit = GitCommit.fromBuffer(objectResult.object as Uint8List);\n        final parentOids = commit.headers().parent;\n        var haveAllParents = parentOids.isEmpty;\n        if (parentOids.isNotEmpty) {\n          final hasParentsResults = await Future.wait(\n              parentOids.map((oid) => hasObject(fs: fs, cache: cache, gitdir: gitdir, oid: oid)).toList());\n          haveAllParents = hasParentsResults.every((has) => has);\n        }\n        if (!haveAllParents) {\n          shallowOids.add(shallowOid);\n        }\n      } catch (_) {\n        shallowOids.add(shallowOid);\n      }\n    }\n  }\n  for (final unshallowOid in uploadPackResponse.unshallows) {\n    shallowOids.remove(unshallowOid);\n  }\n  await GitShallowManager.write(fs: fs, gitdir: gitdir, oids: shallowOids);\n\n  List<String>? prunedRefs;\n  if (singleBranch) {\n    final refsToUpdate = <String, String>{fullref: oid!};\n    final symrefsToUpdate = <String, String>{};\n    var currentSymRef = fullref;\n    for (var i = 0; i < 10; i++) {\n      final value = discovered.symrefs[currentSymRef];\n      if (value == null) break;\n      symrefsToUpdate[currentSymRef] = value;\n      currentSymRef = value;\n    }\n    final realRefOid = filteredRemoteRefs[currentSymRef];\n    if (realRefOid != null) {\n      refsToUpdate[currentSymRef] = realRefOid;\n    }\n\n    final updateResult = await GitRefManager.updateRemoteRefs(\n      fs: fs,\n      gitdir: gitdir,\n      remote: remote,\n      refs: refsToUpdate,\n      symrefs: symrefsToUpdate,\n      tags: tags,\n      prune: prune,\n    );\n    if (prune) {\n      prunedRefs = updateResult.pruned;\n    }\n  } else {\n    final updateResult = await GitRefManager.updateRemoteRefs(\n      fs: fs,\n      gitdir: gitdir,\n      remote: remote,\n      refs: filteredRemoteRefs,\n      symrefs: discovered.symrefs,\n      tags: tags,\n      prune: prune,\n      pruneTags: pruneTags,\n    );\n    if (prune) {\n      prunedRefs = updateResult.pruned;\n    }\n  }\n\n  uploadPackResponse.head = discovered.symrefs[\'HEAD\'];\n  if (uploadPackResponse.head == null) {\n    final headResolved = GitRefManager.resolveAgainstMap(ref: \'HEAD\', map: filteredRemoteRefs);\n    for (final entry in filteredRemoteRefs.entries) {\n      if (entry.key != \'HEAD\' && entry.value == headResolved.oid) {\n        uploadPackResponse.head = entry.key;\n        break;\n      }\n    }\n  }\n\n  final noun = fullref.startsWith(\'refs/tags/\') ? \'tag\' : \'branch\';\n  final fetchHeadInfo = FetchHeadInfo(\n    oid: oid!,\n    description: \'$noun \\\'${abbreviateRef(fullref)}\\\' of $url\',\n  );\n\n  if (onProgress != null || onMessage != null) {\n    final lines = splitLines(uploadPackResponse.progress ?? \'\');\n    await forAwait(lines, (line) async {\n      if (onMessage != null) await onMessage(line);\n      if (onProgress != null) {\n        final matches = RegExp(r\'([^\:]*).*\\((\\d+?)\\/(\\d+?)\\)\').firstMatch(line);\n        if (matches != null) {\n          await onProgress(ProgressEvent(\n            phase: matches.group(1)!.trim(),\n            loaded: int.parse(matches.group(2)!),\n            total: int.parse(matches.group(3)!),\n          ));\n        }\n      }\n    });\n  }\n\n  final packfileData = Uint8List.fromList(await collect(uploadPackResponse.packfile!));\n  if (rawResponse.bodyError != null) throw rawResponse.bodyError!;\n\n  String? packfileSha;\n  if (packfileData.isNotEmpty) {\n     packfileSha = utf8.decode(packfileData.sublist(packfileData.length - 20));\n  }\n  \n\n  final result = FetchResult(\n    defaultBranch: uploadPackResponse.head,\n    fetchHead: fetchHeadInfo.oid,\n    fetchHeadDescription: fetchHeadInfo.description,\n  );\n\n  if (uploadPackResponse.headers != null) {\n    result.headers = uploadPackResponse.headers;\n  }\n  if (prune && prunedRefs != null) {\n    result.pruned = prunedRefs;\n  }\n\n  if (packfileSha != null && packfileSha.isNotEmpty && !emptyPackfile(packfileData)) {\n    result.packfile = \'objects/pack/pack-$packfileSha.pack\';\n    final fullpath = join(gitdir, result.packfile!);\n    await fs.write(fullpath, packfileData);\n\n    Future<ReadObjectResult> getExternalRefDelta(String oid) => readObject(fs: fs, cache: cache, gitdir: gitdir, oid: oid);\n\n    final idx = await GitPackIndex.fromPack(\n      pack: packfileData,\n      getExternalRefDelta: getExternalRefDelta,\n      onProgress: onProgress,\n    );\n    await fs.write(fullpath.replaceAll(RegExp(r\'\\.pack$\'), \'.idx\'), await idx.toBuffer());\n  }\n  return result;\n}\n 